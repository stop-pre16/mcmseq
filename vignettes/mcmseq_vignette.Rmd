---
title: "An Introduction to MCMSeq"
author: "Camille M. Moore"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{An Introduction to MCMSeq}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
As the cost of sequencing decreases, the complexity and size of RNA-Seq experiments are rapidly growing. In particular, paired, longitudinal and other correlated study designs are becoming commonplace.  However, the tools available to analyze these more complex study design are limited. 
It is well known that failing to account for correlation between repeated outcome measurements can result in misleading inferences. For example, when estimating changes in gene expression over time, if there is strong within subject correlation, estimated standard errors will be too large if correlation is ignored, reducing power to detect differential expression over time. Attempting to analyze correlated RNA-Seq data with DESeq2 or edgeR by including all levels of the clustering variable as fixed effects in the regression model can also be problematic. In this case, the number of parameters necessary to account for correlation is equal to the number of subjects or clusters. This may result in a model that is too complex for the number of observations in the study, leading to overfitting. When overfitting is present, some of the findings of the analysis come from fitting noise, resulting in spurious associations and results that cannot be reproduced in future studies. Cui et al (2016) also noted that this strategy led to inflated false positive rates. In addition, if a regression parameter for each subject is included in a model, other effects of interest may not be estimable. For example, in a study comparing gene expression between two groups over time, differences between groups at individual time points can not be estimated.

MCMSeq uses a Bayesian hierarchical negative binomial model to account for correlation in clustered and longitudinal RNA-Seq experiments. This model allows for
the inclusion of random effects that can be used to account for correlation. If desired, information can be borrowed across genes when developing the prior for the dispersion parameter, although in practice, we find this step unnecessary. The model is fit using Markov-chain Monte Carlo (MCMC) methods, which can be compuationally intensive.  The MCMSeq algorithm has been optimized in C++ and can be run in parallel to speed
computation time.

## Model Specification
Similar to other commonly used RNA-Seq analysis tools, we model the observed RNA-Seq count data with a negative binomial distribution with a log link function.  To account for correlation, we allow a random intercept to be included in the model. Let $Y_{gij}$ be the expression of gene $g$ from subject $i$ at time point or observation $j$, then
\begin{eqnarray}
\label{eqn:glmm}
Y_{gij} &\sim& \mathcal{NB}(\mu_{gij}, \alpha_g) \\
\log(\mu_{gij}) &=& X_{ij}\boldsymbol{\beta_g} + b_{gi} + \rho_{ij}\\
{b_{gi}} &\sim& \mathcal{N}(0, \sigma_g^2)
\end{eqnarray}
where $\mu_{gij}$ is the mean expression of gene $g$ in subject $i$ at observation $j$ and $\alpha_g$ is the dispersion parameter for gene $g$, which is related to the variance of $Y_{gij}$ by Var($Y_{gij}$) = $\mu_{gij} + \alpha_g \mu_{gij}^2$. $\boldsymbol{\beta_g}$ is a $p$ by 1 vector of fixed effect regression coefficients for gene $g$, $X_{ij}$ is a row vector of fixed effects covariates for subject $i$ at observation $j$, $b_{gi}$ is a random intercept for gene $g$ and subject $i$, and $\rho_{ij}$ is an offset for subject $i$ at observation $j$, which can be used to account for differences in sequencing depth between samples. We assume that for each gene, the subject-specific random intercept is normally distributed with mean 0 and variance $\sigma_g^2$. 

The Bayesian hierarchical model is completed by specifying priors (and hyper-priors) for $\boldsymbol{\beta_g}$, $\sigma_g^2$, and $\alpha_g$:
\begin{eqnarray*}
\boldsymbol{\beta_g} &\sim& \mathcal{MVN}(M_g, I_p s^2) \\
%b_{gi} &\sim& \mathcal{N}(0, \Sigma_{g}) \\
\sigma_g^2 &\sim& \mathcal{IG}(U, V) \\
\log(\alpha_g) &\sim& \mathcal{N}(A_g, B) 
\end{eqnarray*}
where $M_g$ is a vector of length $p$ containing the prior means for the fixed effect regression coefficients for gene $g$, $I$ is a $p$ x $p$ Identity matrix, $s^2$ is the prior variance for the fixed effect coefficients, $\mathcal{MVN}$ is the multivariate normal distribution, and $\mathcal{IG}$ is the inverse Gamma distribution with parameters $U$ and $V$. We use a log normal prior for the dispersion paramters, $alpha_g$, with prior mean $A$ and prior variance $B$.   

## An Example MCMSeq Analysis Using Default Priors
We will perform an analysis on a simulated dataset.  The data is included as part of the mcmseq package and includes simulated expression count data on 6 subjects (ids 1 to 6): 3 control subjects (group = 0) and 3 treatment subjects (group = 1).  All subjects are measured at 2 timepoints, baseline (time = 0) and follow-up (time = 1).  1,000 genes are included in the dataset, 200 of which were simulated to have changes in expression from baseline to follow up in the treatment group only. First load the data:
```{r}
# Load the mcmseq library
library(mcmseq)

# Load the data
data("simdata")
class(simdata)
names(simdata)

# metadata has information about the the study design
# each row is a sample and corresponds to a column
# in the counts matrix
metadata <- simdata$metadata
metadata

# The counts matrix has the same number of columns as
# rows in metadata.  The columns of the counts matrix
# are in the same order as the rows of the metadata.
counts <- simdata$counts
head(counts)

# The de element indicates which genes were simulated to have differential expression
length(simdata$de)
```
The goal of our analysis will be to compare changes over time between the control and treatment groups.  We will fit the following model to the data:

\begin{eqnarray}
 \label{eq:sim_data}
Y_{gij} &\sim& \mathcal{NB}(\mu_{gij}, \alpha_g) \nonumber \\
\log(\mu_{gij}) &=& \beta_{g0} + \beta_{g1} I_{T_i} + \beta_{g2} I_{F_{ij}} +  \\
			&&	\beta_{g3}I_{T_i} I_{F_{ij}} + b_{gi} + \rho_{ij} \nonumber \\
b_{gi} &\sim& \mathcal{N}(0, \sigma_{gb}^2) \nonumber
\end{eqnarray}
 where $I_{T_i}$ is an indicator function that equals 1 if subject $i$ is in the treatment group, $I_{F_{ij}}$ is a similar indicator for if observation $j$ is the follow-up, $b_{gi}$ is the random intercept for gene $g$ and subject $i$ and $\rho_{ij}$ is an offset for subject $i$ at observation $j$ to account for differences in sequencing depth.   
 
```{r}
# Create the fixed effects model formula
f <- ~ group*time

```

### Choice of Priors
We include default values for all proir and hyperprior parameters.  For our defaults, we set the first element of $M_g$ (the prior mean for the intercept) to be the log of the mean number of counts across samples for that gene; all other elements of $M_g$ are set to 0 to be non-informative. We similarly choose the prior variance for the fixed effect coefficients to be large by setting $s=7$ and set $U$ and $V$ to small values (e.g. 0.01) in order to be uninformative. For the dispersion parameter, we choose a prior mean of $A = -log(7)$ for all genes, which would inidicate little over-dispersion / Poisson behavior and chose a large prior variance of $B=7^2$. 

We believe that these are reasonable prior choices for a variety of problems; however, all of these parameters can be specified by the user to tailor priors to a particular problem or dataset.

### Choice of Proposal Distributions
By default fixed and random effect regression coefficients are updated using a Metropolis Hastings step with a weighted least squares proposal, as described by Gammerman (YEAR).  We have extensively tested this proposal for use in negative binomial mixed models and negative binomial regression models. Typically acceptance rates for this type of proposal are quite high. In pratice, we consider features that have > 10\% accepts to have converged in terms of the fixed and random effect coefficients. However, if acceptance rates are low, we offer a random walk proposal,  which can tried for features that do not converge using the WLS proposal. A random walk proposal can be chosen by changing proposal_method = 'wls' to proposal_method = 'rw' in the mcmseq.fit function.  If proposal_method = 'rw', then a "step size" or standard deviation for the random walk proposal distribution must be selected (rw_sd_betas). This parameter may need to be tuned in order to achieve appropriate mixing and acceptance probabilities.

Similarly, the dispersion parameters are also updated using a random walk proposal with a standard deviation of rw_sd_log_alpha.  This parameter may need to be tuned in order to achieve appropriate mixing and acceptance probabilities.

For random walk proposals, acceptance rates around 23\% are considered optimal.  In practice, we filter out features that have acceptance probabilities less than 10\% and greater than 70\% accepts for random walk proposals.  If many features have acceptance rates outside these limits, you should consider changing rw_sd_log_alpha (or rw_sd_betas for coefficients).  To increase acceptance rates, reduce the value of rw_sd_log_alpha.  To decrease acceptance rates increase rw_sd_log_alpha.  Before running mcmseq on your full dataset, you may want to do a test run with a small number of features (1,000) and adjust random walk standard deviations as needed. 


### Accounting for Differences in Sequencing Depth
As a default, an offset is included to account for sequencing depth.  We calculate the offset for subject $i$ at observation $j$ as $\rho_{ij} = \frac{Q^{75}_{ij}}{\text{median}_{rs} (Q^{75}_{rs})}$, where $Q^{75}_{ij}$ is the 75$^{th}$ percentile of counts across genes for subject $i$ at observation $j$.  Other choices might include the total library size for an observation, the median of ratios method from DESeq2 or the trimmed mean of M values from EdgeR.

### Setting Up Contrasts
In addition, we are interested in the following contrasts or linear combinations of regression paramters:
- $\beta_{g1} + \beta_{g3} = 0$ tests for differences in expression between the treatment and the control group at follow-up

- $\beta_{g2} + \beta_{g3} = 0$ tests for a change in expression over time in the treatment group

The mcmseq fitting function allows users to specify custom contrasts or linear combinations of the fixed effects regression coefficients for testing through the contrast_mat argument.  The contrast matrix must have the same number of columns as fixed effects and each row corresponds to a different contrast to test.  In addition, the user can specify contrasts names either by naming the rows of the contrast matrix of by supplying a character vector of contrast names to the contrast_names argument.  

The fixed effects in the contrast matrix must be in the same order specified by the model formula.  If you are unsure of the ordering, mcmseq.fit uses the model.matrix function to create a design matrix for the fixed effects based on the fixed_effects formula supplied by the user.  To see the design matrix for the formula:

```{r}
# Look at the fixed effects design matrix to develop the contrast_mat
head(model.matrix(f, data = metadata))

# Create the contrast matrix
contrasts <- rbind(c(0,1,0,1), # group + group:time
                   c(0,0,1,1)  # time + group:time 
              )

# Name the contrasts by specifying rownames
rownames(contrasts) <- c("Treatment_v_Control_at_FollowUp", 
                         "FollowUp_v_Baseline_in_Treatment")

# View the contrast matrix
contrasts
```
### Fitting the Model
To fit the model, we use the mcmseq.fit function.  Default values are specified for all priors. The counts argument takes a data frame or matrix of counts, the columns of which must be in the same order as the rows of sample_data data frame, which contains metadata on each sample.  All fixed effects specified in the fixed_effects formula as well as any random effects specified in the random_intercept argument must be included in the sample_data data frame. To include a random intercept for each subject in the model, specify the name of the sample_data column that contains the subject identifier.  By default, the mcmseq.fit will use rownames of the counts matrix to identify genes.  If you would like to use a different set of gene names, you can supply a character vector of names in the same order as the rows of the counts matrix to the gene_names argument.  Since we named the rows of our contrast matrix, we leave the contrast_names argument at its default NULL value.  To quickly illustrate how the package works, we set the number of iterations to 1,000, however, in practice we suggest using a much higher number of iterations for mixed model fits (>30,000).  prop_burn_in specifies the proportion of the chain that should be used for burn in, to allow for MCMC convergence.  The default is 10\%. 
```{r}
# Fit the Model
fit.default <- mcmseq.fit(counts=counts, 
                       fixed_effects = f,
                       sample_data = metadata,
                       random_intercept = 'ids', 
                       gene_names = paste0('gene_', seq(1,1000,1)),
                       contrast_mat = contrasts,
                       contrast_names = NULL,
                       n_it = 1000,
                       prop_burn_in = 0.1
)

# Look at the mcmseq fit object
class(fit.default)

names(fit.default)
```

The resulting mcmseq object is a list.  Elements 7-23 of the list provide information about the user supplied and/or default settings used to fit the model.  "betas_est" is a 3 dimensional array (number of fixed effects x 4 x number of genes), which contains the posterior median, standard deviation, Bayes factor, and raw pseudo p-value for each regression coefficient for each gene.  Similarly, "contrast_est" is a 3 dimensional array (number contrasts x 4 x number of genes), containing the same information for each contrast. "alphas_est" contains the dispersion parameters for each gene, and  "sig2_est" contains the random intercept variance for each gene.  "accepts_betas" contains the number of iterations where a proposal for the regression coefficients was accepted, which provides information about the mixing of the chain. Similarly, "accepts_alphas" provides the number of accepts for updates of the dispersion parameter. If the chain does not have an appropirate acceptance rate, then the chain for that gene may not be adequately converged to make inference (See section XXX).   
```{r}
# See regression coefficient estimates for the first gene
fit.default$betas_est[,,1]

# See the contrast estimates for the first gene
fit.default$contrast_est[,,1]

# See the dispersion and random intercept variance estimates for the
# first 10 genes
fit.default$alphas_est[1:10]
fit.default$sig2_est[1:10]

# Calculate and check acceptance rates for the first 10 features
# Dispersion accepts
fit.default$accepts_alphas[1:10]/fit.default$n_it

# Coefficient accepts
fit.default$accepts_betas[1:10]/fit.default$n_it
```


### Summarizing Results
Results can be more easily summarized with the mcmseq.summarize function, which calculates Benjamini-Hochberg adjusted p-values and allows for filtering and ordering of results into tables. By default, results will be presented in the same order in which they were supplied in the counts matrix.  However, results can be ordered by "posterior_median" (the posterior median of the regression coefficient or contrast of interest), "posterior_median_abs" (the absolute value of the posterior median), "BF" the Bayes factor, "exact_pval" (raw p-value), or "BH_adjusted_pval" (the Benjamini-Hochberg adjusted p-value).  Results can be retrieved in either descending or ascending order by setting the decreasing option to TRUE or FALSE, respectively.  Results can also be filtered by one or more of these same variables, using the filter_by argument, which takes a character vector of variables to filter by.  The filter_val option allows the user to specify filtering values for each variable listed in filtery_by.  The gt option is a vector of logicals indicating if values greater than (vs. less than) filter_val(s) should be excluded from the results table.  

By default results are presented on the natural log scale.  If you would prefer to see results on the log2 scale, use the log2 = TRUE option. 

Importantly, the mcmseq.summarize function also filters out genes that have low acceptance rates and may not have converged.  The default values are....For the weighted least squares proposal for fixed and random effects, we suggest an acceptance rate of at least 10\% for to make inference on a gene.  For disperiosn parameters, the acceptance rate should be between 15\% and 40\% 

```{r}
# Summarize results for the first contrast, on the log2 scale
c1_table <- mcmseq.summarize(mcmseqModel = fit.default, 
                 summarizeWhat="contrast",  
                 which = "Treatment_v_Control_at_FollowUp",  
                 prop.accepts.coef = c(0.1,1), 
                 prop.accepts.dispersion  = c(0.1,0.7),
                  log2=TRUE 
            )

dim(c1_table)

head(c1_table)

# Filter out genes with effect sizes less than 1 and BH adjusted p-values > 0.05
# Order results by BH adjusted p-value
c1_table_filtered <- mcmseq.summarize(mcmseqModel = fit.default, 
                 summarizeWhat="contrast",  
                 which = "Treatment_v_Control_at_FollowUp",  
                 prop.accepts.coef = c(0.1,1), 
                 prop.accepts.dispersion  = c(0.1,0.7),
                 order_by = "BH_adjusted_pval", 
                 decreasing = FALSE,
                 filter_by = c("BH_adjusted_pval", "posterior_median_abs"),
                 filter_val = c(0.05, 1),
                 gt = c(FALSE, TRUE),
                  log2=TRUE 
            )

dim(c1_table_filtered)

head(c1_table_filtered)

# Do the same for the group coefficient which represnts the difference 
# between treatment and control at baseline
group_table_filtered <- mcmseq.summarize(mcmseqModel = fit.default, 
                 summarizeWhat="coefficient",  
                 which = "group",  
                 prop.accepts.coef = c(0.1,1), 
                 prop.accepts.dispersion  = c(0.1,0.7),
                 order_by = "BH_adjusted_pval", 
                 decreasing = FALSE,
                 filter_by = c("BH_adjusted_pval", "posterior_median_abs"),
                 filter_val = c(0.05, 1),
                 gt = c(FALSE, TRUE),
                  log2=TRUE 
            )

dim(c1_table_filtered)

head(c1_table_filtered)

```

## What if the acceptance probability is low for a gene?
You can determine which genes were filtered from results due to low acceptance probabilites by looking at the number of accepts.  In our example above no genes were filtered due to acceptance rates.  Below we determine which genes are outside of a more narrow acceptance range:
```{r}
# Create a more narrow acceptance range
limits.dispersion <- c(0.15, 0.45)
limits.betas <- c(0.3, 0.9)

# Determine which genes are outside the dispersion accept range
disp.id <- which( (fit.default$accepts_alphas/fit.default$n_it) < limits.dispersion[1] |
         (fit.default$accepts_alphas/fit.default$n_it) > limits.dispersion[2])

head(fit.default$gene_names[disp.id])

# Coefficient accepts
beta.id <- which( (fit.default$accepts_betas/fit.default$n_it) < limits.betas[1] |
         (fit.default$accepts_betas/fit.default$n_it) > limits.betas[2])

head(fit.default$gene_names[beta.id])

```
If features fail due to the dispersion paramter, try adjusting XXX and re-running mcmseq on the subset of genes that failed. If features fail due to the regression coefficients, try using a random walk proposal for the coefficients instead of the WLS method.


## An Example MCMSeq Analysis Using Custom Priors: Sharing Information Across Genes


## Figures

The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
plot(1:10)
plot(10:1)
```

